# 1 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino"
# 1 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino"
/********************************************************
  # NAME: boilerplate.ino
  # AUTHOR: Simone Mora (simonem@ntnu.no)
  # DATE: 
  # LICENSE: Apache V2.0
********************************************************/

# 9 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino" 2
# 10 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino" 2
# 11 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino" 2
# 12 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino" 2

# 14 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino" 2

# 16 "/Users/Simone/Desktop/Tiles/bolierplate/boilerplate/boilerplate.ino" 2
//#include "MATRIX.h"

//Variables for timing
uint_fast16_t volatile number_of_ms = 10; // ms

// VARIABLES FOR BLUETOOTH
BLE_Handler BLE;

// Variables for Sensors
Sensors_Handler sensor_handle(&BLE);
ADXL345 *Accelerometer = __null;
LSM9DS0 *IMU = __null;

CAP1188 *TOUCH = __null;

// Variables for Feedbacks 
Feedbacks_Handler feedback_handle;
//Haptic *HapticMotor;
//RGB_LED *LED;
NEO_STRIP *STRIP;
//#define VIBRATING_M_PIN     3 // Pin where the vibrating motor is connected
MATRIX *M_MATRIX = __null;


void setup(void)
{
    override_uart_limit = 0x1;
    Serial.begin(9600);
    __enable_irq(); // Enable interrupts

    // Initialization of Sensors
    Accelerometer = new ADXL345(4 /* Pin where the acceleromter interrupt1 is connected*/);
    IMU = new LSM9DS0();
    TOUCH = new CAP1188(0);
    sensor_handle.setAccelerometer(Accelerometer);
    sensor_handle.setInertialCentral(IMU);
    sensor_handle.setTouchSensor(TOUCH);
    RFduino_pinWakeCallback(3, 1, callback);

    // Intitialization of Feedbacks
    STRIP = new NEO_STRIP();
    M_MATRIX = new MATRIX(0);

    feedback_handle.setNEO_STRIP(STRIP);
    //delay(100);
    feedback_handle.setColor("black");
    feedback_handle.setMATRIX(M_MATRIX);

    // HapticMotor = new Haptic(VIBRATING_M_PIN);
    // LED = new RGB_LED(0, 1, 2);
    // TokenFeedback.setHapticMotor(HapticMotor);
    // TokenFeedback.setRGB_LED(LED);

    // Configure the RFduino BLE properties
    char DeviceName[8] = {0};
    BLE.AdvertiseName.toCharArray(DeviceName, 8);
    RFduinoBLE.deviceName = DeviceName;
    RFduinoBLE.txPowerLevel = -20;

    // Start the BLE stack
    RFduinoBLE.begin();
    Serial.println("Setup OK!");
    timer_config();
}

void loop(void)
{
    sensor_handle.pollEvent();
    feedback_handle.UpdateFeedback();
    BLE.ProcessEvents();
    delay(10); // 10ms Important delay, do not delete it, increased to 20 to match frame rates
}



void timer_config(void)
{
    ((NRF_TIMER_Type *) 0x40009000UL)->TASKS_STOP = 1; // Stop timer
    ((NRF_TIMER_Type *) 0x40009000UL)->MODE = (0UL) /*!< Timer in Normal mode. */; // sets the timer to TIME mode (doesn't make sense but OK!)
    ((NRF_TIMER_Type *) 0x40009000UL)->BITMODE = (0x00UL) /*!< 16-bit timer behaviour. */; // with BLE only Timer 1 and Timer 2 and that too only in 16bit mode
    ((NRF_TIMER_Type *) 0x40009000UL)->PRESCALER = 9; // Prescaler 9 produces 31250 Hz timer frequency => t = 1/f =>  32 uS
                                                                     // The figure 31250 Hz is generated by the formula (16M) / (2^n)
                                                                     // where n is the prescaler value
                                                                     // hence (16M)/(2^9)=31250
    ((NRF_TIMER_Type *) 0x40009000UL)->TASKS_CLEAR = 1; // Clear timer

    //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    //        Conversion to make cycle calculation easy
    //        Since the cycle is 32 uS hence to generate cycles in mS we need 1000 uS
    //        1000/32 = 31.25  Hence we need a multiplication factor of 31.25 to the required cycle time to achive it
    //        e.g to get a delay of 10 mS      we would do
    //        NRF_TIMER2->CC[0] = (10*31)+(10/4);
    //-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    ((NRF_TIMER_Type *) 0x40009000UL)->CC[0] = (number_of_ms * 31) + (number_of_ms / 4); //CC[0] register holds interval count value i.e your desired cycle
    ((NRF_TIMER_Type *) 0x40009000UL)->INTENSET = (1UL) /*!< Interrupt enabled. */ << (16UL) /*!< Position of COMPARE0 field. */; // Enable COMAPRE0 Interrupt
    ((NRF_TIMER_Type *) 0x40009000UL)->SHORTS = ((1UL) /*!< Shortcut enabled. */ << (0UL) /*!< Position of COMPARE0_CLEAR field. */); // Count then Complete mode enabled
    attachInterrupt(TIMER1_IRQn, TIMER1_Interrupt); // also used in variant.cpp in the RFduino2.2 folder to configure the RTC1
    ((NRF_TIMER_Type *) 0x40009000UL)->TASKS_START = 1; // Start TIMER
}

void TIMER1_Interrupt(void)
{
    if (((NRF_TIMER_Type *) 0x40009000UL)->EVENTS_COMPARE[0] != 0)
    {
        sensor_handle.HandleTime(number_of_ms);
        feedback_handle.HandleTime(number_of_ms);
        ((NRF_TIMER_Type *) 0x40009000UL)->EVENTS_COMPARE[0] = 0;
    }
}


int callback(uint32_t ulPin)
{
  Serial.println("callback");
  Serial.println("touched");
}
